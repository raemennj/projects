<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Liquid Glass Blobs — Draggable</title>
<style>
  /* ---- Page background to refract/blur ---- */
  :root { color-scheme: light dark; }
  html, body {
    height: 100%;
    margin: 0;
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
    background:
      radial-gradient(1200px 800px at 10% 10%, rgba(255,255,255,.25), transparent 60%),
      radial-gradient(900px 700px at 90% 80%, rgba(255,255,255,.12), transparent 60%),
      linear-gradient(120deg, #2a5bd7, #7b49d9 40%, #06c0a7);
    background-attachment: fixed;
  }

  /* Scene layer to hold blobs */
  .scene {
    position: fixed;
    inset: 0;
    touch-action: none; /* we’ll handle gestures */
    user-select: none;
  }

  /* ---- Liquid glass blob ---- */
  .blob {
    position: absolute;
    width: 180px; height: 180px;
    border-radius: 42% 58% 55% 45% / 47% 38% 62% 53%; /* organic shape */
    background:
      radial-gradient(120% 100% at 20% 20%, rgba(255,255,255,.55), rgba(255,255,255,.12) 35%, rgba(255,255,255,0) 60%),
      radial-gradient(60% 55% at 70% 75%, rgba(255,255,255,.25), rgba(255,255,255,0) 60%);
    backdrop-filter: blur(18px) saturate(120%);          /* the frosted glass magic */
    -webkit-backdrop-filter: blur(18px) saturate(120%);
    background-clip: padding-box;
    border: 1px solid rgba(255,255,255,.45);
    box-shadow:
      inset 0 0.5px 0.5px rgba(255,255,255,.6),          /* inner sheen */
      inset 0 -10px 25px rgba(255,255,255,.12),          /* inner ambient */
      0 25px 50px rgba(0,0,0,.25);                       /* soft drop */
    transition: box-shadow 180ms ease, transform 180ms ease;
    cursor: grab;
    will-change: transform;
  }
  .blob::after { /* specular highlight streak */
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background:
      conic-gradient(from 210deg at 70% 25%, rgba(255,255,255,.28), rgba(255,255,255,0) 25% 85%, rgba(255,255,255,.18));
    mix-blend-mode: screen;
    pointer-events: none;
    opacity: .6;
    filter: blur(0.3px);
  }
  .blob.dragging {
    cursor: grabbing;
    box-shadow:
      inset 0 0.5px 0.5px rgba(255,255,255,.7),
      inset 0 -12px 28px rgba(255,255,255,.14),
      0 30px 60px rgba(0,0,0,.35);
    transform: scale(1.03);
  }

  /* Tiny “liquid wobble” while idle */
  @keyframes wobble {
    0%   { border-radius: 42% 58% 55% 45% / 47% 38% 62% 53%; }
    50%  { border-radius: 45% 55% 52% 48% / 49% 36% 60% 55%; }
    100% { border-radius: 42% 58% 55% 45% / 47% 38% 62% 53%; }
  }
  .blob { animation: wobble 6s ease-in-out infinite; }

  /* Label (optional) */
  .label {
    position: absolute;
    bottom: 10px; left: 12px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif;
    font-size: 12px; letter-spacing: .2px;
    color: rgba(0,0,0,.7);
    mix-blend-mode: multiply;
    text-shadow: 0 1px 0 rgba(255,255,255,.45);
    pointer-events: none;
    user-select: none;
  }

  /* Backdrop-filter fallback */
  @supports not ((backdrop-filter: blur(10px)) or (-webkit-backdrop-filter: blur(10px))) {
    .blob {
      background: radial-gradient(120% 100% at 20% 20%, rgba(255,255,255,.35), rgba(255,255,255,.08) 35%, rgba(255,255,255,0) 60%);
      /* Simulate “glass” with more translucency + outer blur */
      filter: saturate(110%);
    }
  }
</style>
</head>
<body>
  <div class="scene" id="scene" aria-label="Liquid glass scene"></div>

<script>
(function () {
  const scene = document.getElementById('scene');

  // ---- Utility: clamp value between min/max ----
  const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

  // ---- Create a blob element ----
  function makeBlob({ x, y, size = 180, text = '' } = {}) {
    const el = document.createElement('div');
    el.className = 'blob';
    el.style.width = el.style.height = size + 'px';
    el.style.left = (x ?? 60) + 'px';
    el.style.top  = (y ?? 60) + 'px';

    if (text) {
      const lbl = document.createElement('div');
      lbl.className = 'label';
      lbl.textContent = text;
      el.appendChild(lbl);
    }
    makeDraggable(el);
    scene.appendChild(el);
    return el;
  }

  // ---- Draggable with pointer events (mouse + touch + pen) ----
  function makeDraggable(el) {
    let originX = 0, originY = 0;
    let startLeft = 0, startTop = 0;
    let pointerId = null;
    let lastT = 0, vx = 0, vy = 0; // for a tiny bit of inertial feel

    const onDown = (e) => {
      if (pointerId !== null) return;
      el.setPointerCapture(e.pointerId);
      pointerId = e.pointerId;
      el.classList.add('dragging');
      originX = e.clientX; originY = e.clientY;
      const rect = el.getBoundingClientRect();
      startLeft = rect.left; startTop = rect.top;
      lastT = performance.now(); vx = vy = 0;
    };

    const onMove = (e) => {
      if (e.pointerId !== pointerId) return;
      const dx = e.clientX - originX;
      const dy = e.clientY - originY;

      // keep inside the viewport
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const w = el.offsetWidth, h = el.offsetHeight;

      let nx = clamp(startLeft + dx, 0, vw - w);
      let ny = clamp(startTop + dy, 0, vh - h);

      el.style.left = nx + 'px';
      el.style.top  = ny + 'px';

      // velocity estimate
      const now = performance.now();
      const dt = (now - lastT) / 1000;
      if (dt > 0) {
        vx = (dx) / dt;
        vy = (dy) / dt;
      }
      lastT = now;
    };

    const onUp = (e) => {
      if (e.pointerId !== pointerId) return;
      el.releasePointerCapture(pointerId);
      pointerId = null;
      el.classList.remove('dragging');

      // small inertial glide
      const start = performance.now();
      const friction = 2800; // px/s^2
      const sign = (n) => (n < 0 ? -1 : 1);

      let x = parseFloat(el.style.left);
      let y = parseFloat(el.style.top);

      function step(ts) {
        const t = (ts - start) / 1000;
        const ax = -sign(vx) * friction;
        const ay = -sign(vy) * friction;
        const vx_t = Math.abs(vx) > 1 ? vx + ax * t : 0;
        const vy_t = Math.abs(vy) > 1 ? vy + ay * t : 0;

        // position using simple integration
        x += vx_t * (1/60);
        y += vy_t * (1/60);

        // clamp to viewport bounds
        const vw = window.innerWidth, vh = window.innerHeight;
        const w = el.offsetWidth, h = el.offsetHeight;
        x = clamp(x, 0, vw - w); y = clamp(y, 0, vh - h);

        el.style.left = x + 'px';
        el.style.top  = y + 'px';

        // stop when velocity is low
        if (Math.abs(vx_t) > 5 || Math.abs(vy_t) > 5) {
          vx = vx_t; vy = vy_t;
          requestAnimationFrame(step);
        }
      }
      requestAnimationFrame(step);
    };

    el.addEventListener('pointerdown', onDown);
    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
    window.addEventListener('pointercancel', onUp);
  }

  // ---- Spawn a few blobs ----
  const vw = window.innerWidth, vh = window.innerHeight;
  makeBlob({ x: vw*0.15, y: vh*0.18, size: 190, text: 'drag me' });
  makeBlob({ x: vw*0.55, y: vh*0.35, size: 220, text: 'glass' });
  makeBlob({ x: vw*0.30, y: vh*0.60, size: 160, text: 'liquid' });

  // Tap/Click empty space to add a new blob quickly
  scene.addEventListener('pointerdown', (e) => {
    if (e.target !== scene) return;
    makeBlob({ x: e.clientX - 90, y: e.clientY - 90, size: 160 });
  });

  // Keep blobs inside on resize/rotate
  window.addEventListener('resize', () => {
    const vw = window.innerWidth, vh = window.innerHeight;
    document.querySelectorAll('.blob').forEach(el => {
      const w = el.offsetWidth, h = el.offsetHeight;
      const x = clamp(parseFloat(el.style.left||0), 0, vw - w);
      const y = clamp(parseFloat(el.style.top ||0), 0, vh - h);
      el.style.left = x + 'px';
      el.style.top  = y + 'px';
    });
  });
})();
</script>
</body>
</html>
