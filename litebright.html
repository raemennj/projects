<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Lite Bright</title>

  <style>
    /* Reset and full-height layout */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: black;
      color: white;
      font-family: Arial, sans-serif;
      overflow: hidden; /* Prevent accidental scrolling */
    }

    /* CSS Variables */
    :root {
      --selected-color: #FF0000; /* Default color (Red) */
      --header-transition-duration: 0.5s;
    }

    /* The page is split: a header at top, the rest is flexible main content */
    body {
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1rem;
      background: linear-gradient(to bottom, var(--selected-color), #111);
      transition: background var(--header-transition-duration) ease;
      box-sizing: border-box;
      flex-shrink: 0;
      position: relative;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    header h1 {
      margin: 0 0 1rem;
      font-size: 1.5rem;
      text-align: center;
    }

    .selector-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    /* Custom Dropdown Styles */
    .custom-dropdown {
      position: relative;
      display: inline-block;
      cursor: pointer; /* Ensure cursor indicates clickable area */
    }

    .dropdown-button {
      background-color: #333;
      color: white;
      padding: 0.25rem 0.5rem;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      width: 200px; /* Adjust width as needed */
      box-sizing: border-box;
    }

    .dropdown-button::after {
      content: '▼';
      font-size: 0.6rem;
      margin-left: auto;
    }

    .dropdown-content {
      display: grid; /* Define as a grid container */
      grid-template-columns: 1fr 1fr; /* Create two equal columns */
      gap: 0.5rem; /* Space between grid items */
      padding: 0.5rem 0; /* Adds vertical padding */
      background-color: #111; /* Ensure background matches your design */
      border-radius: 4px; /* Optional: Adds rounded corners */
      position: absolute;
      width: 300px;
      top: 100%;
      left: 0;
      right: 0;
      z-index: 1000; /* Ensure it appears above other elements */
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      display: none; /* Hidden by default */
    }

    .dropdown-content.show {
      display: grid; /* Ensure grid layout remains when shown */
    }

    .dropdown-item {
      display: flex; /* Align items horizontally */
      align-items: center;
      padding: 0.5rem 1rem; /* Adjust padding as needed */
      box-sizing: border-box;
      cursor: pointer; /* Change cursor on hover */
      border-radius: 4px; /* Optional: Adds rounded corners */
      transition: background-color 0.2s ease, transform 0.2s ease;
      outline: none; /* Remove default outline */
    }

    .dropdown-item:hover,
    .dropdown-item:focus {
      background-color: #555; /* Hover and focus effect */
      transform: scale(1.02); /* Slightly enlarges the item on hover/focus */
    }

    .dropdown-item.active {
      background-color: #666; /* Active state */
    }

    .swatch {
      position: relative;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .swatch::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: white;
      opacity: 0.3;
    }

    /* The main content fills all remaining space below the header */
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    /* The board container will fill the entire main content area */
    .board-container {
      position: relative;
      flex: 1;            /* Fill remaining vertical space */
      border: 1px solid #444;
      background-color: black;
      
      /* Prevent the page from scrolling when a user swipes/drag inside this container */
      touch-action: none;
    }

    /* The SVG that holds the pegs */
    #lightBrightBoard {
      width: 100%;
      height: 100%;
      display: block;
      background-color: black;
    }

    select, button {
      font-size: 1rem;
      padding: 0.25rem 0.5rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    select {
      background-color: #333;
      color: white;
    }

    select:focus, button:focus {
      outline: none;
      box-shadow: 0 0 0 2px #00ffff;
    }

    button {
      background-color: #444;
      color: white;
      margin-left: 0.5rem;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    button.active {
      background-color: #00ffff;
      color: black;
    }

    button:hover {
      background-color: #555;
    }

    /* Sweep Animation */
    @keyframes sweepGradient {
      from {
        background-position: top;
      }
      to {
        background-position: bottom;
      }
    }

    header.animate-sweep {
      animation: sweepGradient var(--header-transition-duration) ease forwards;
    }

    /* Solid background when eraser mode is active */
    header.eraser-mode {
      background: #111; /* Changed from grey to #111 */
      transition: background var(--header-transition-duration) ease;
    }

    /* Responsive Design: Single Column on Small Screens */
    @media (max-width: 600px) {
      .dropdown-content {
        grid-template-columns: 1fr; /* Switch to single column on small screens */
      }

      .dropdown-button {
        width: 100%; /* Make dropdown button full width on small screens */
      }
      
      /* Adjust modal size for small screens */
      .modal-content {
        width: 95%;
        max-width: 95%;
      }

      /* Adjust save-slot layout */
      .save-slot {
        flex-direction: column;
        align-items: flex-start;
      }

      .save-slot-info {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      .save-slot-preview {
        margin-left: 0;
        margin-top: 0.5rem;
      }

      .save-slot-buttons {
        margin-left: 0;
        margin-top: 0.5rem;
      }

      /* Ensure buttons take full width */
      .save-slot-buttons button {
        width: 100%;
      }

      .save-slot-buttons {
        width: 100%;
      }
    }

    /* Scroll Indicators (optional) */
    .dropdown-content::before,
    .dropdown-content::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: 1rem;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(68, 68, 68, 0.8), rgba(68, 68, 68, 0));
    }

    .dropdown-content::after {
      top: 100%;
      transform: translateY(-1rem);
      background: linear-gradient(to top, rgba(68, 68, 68, 0.8), rgba(68, 68, 68, 0));
    }

    /* Modal Styles */
    .modal {
      display: none; /* Hidden by default */
      position: fixed;
      z-index: 2000; /* Above other elements */
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.8); /* Black w/ opacity */
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: #222;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #444;
      width: 90%;
      max-width: 800px;
      border-radius: 8px;
      color: white;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .close-modal {
      background: none;
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .save-slots {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1rem;
      max-height: 70vh;
      overflow-y: auto;
    }

    .save-slot {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #333;
      padding: 0.5rem;
      border-radius: 4px;
    }

    .save-slot-info {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
      position: relative;
    }

    .save-slot-info input {
      background-color: #555;
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      width: 150px;
      box-sizing: border-box;
      font-size: 1rem;
    }

    .save-slot-info input::placeholder {
      color: #ccc;
    }

    .save-slot-info input:focus {
      outline: none;
      box-shadow: 0 0 0 2px #00ffff;
    }

    .save-slot-info .save-name-button {
      background: none;
      border: none;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
      margin-left: 0.5rem;
      transition: color 0.2s ease;
    }

    .save-slot-info .save-name-button:hover {
      color: #00ffff;
    }

    .save-slot-buttons {
      display: flex;
      gap: 0.5rem;
      margin-left: 1rem;
    }

    .save-slot-buttons button {
      background-color: #555;
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .save-slot-buttons button:hover {
      background-color: #666;
    }

    .save-slot-buttons button.delete-button {
      background-color: #d9534f; /* Red for delete */
    }

    .save-slot-buttons button.delete-button:hover {
      background-color: #c9302c;
    }

    .save-slot-buttons button.save-button {
      background-color: #5bc0de; /* Blue for save */
    }

    .save-slot-buttons button.save-button:hover {
      background-color: #31b0d5;
    }

    /* Thumbnail Preview Styles */
    .save-slot-preview {
      width: 60px;
      height: 60px;
      background-color: #111;
      border: 1px solid #444;
      border-radius: 4px;
      overflow: hidden;
      margin-left: 1rem;
      flex-shrink: 0;
    }

    .save-slot-preview svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Confirmation Modal Styles */
    .confirmation-modal {
      display: none; /* Hidden by default */
      position: fixed;
      z-index: 3000; /* Above all */
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.8);
      justify-content: center;
      align-items: center;
    }

    .confirmation-content {
      background-color: #222;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #444;
      width: 80%;
      max-width: 400px;
      border-radius: 8px;
      color: white;
      text-align: center;
      position: relative;
    }

    .confirmation-buttons {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 1rem;
    }

    .confirmation-buttons button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .confirmation-buttons button.confirm {
      background-color: #5cb85c; /* Green */
      color: white;
    }

    .confirmation-buttons button.confirm:hover {
      background-color: #4cae4c;
    }

    .confirmation-buttons button.discard {
      background-color: #d9534f; /* Red */
      color: white;
    }

    .confirmation-buttons button.discard:hover {
      background-color: #c9302c;
    }

    .confirmation-buttons button.cancel {
      background-color: #777; /* Grey */
      color: white;
    }

    .confirmation-buttons button.cancel:hover {
      background-color: #666;
    }

    /* Scroll Indicators for Modal Content */
    .save-slots::-webkit-scrollbar {
      width: 8px;
    }

    .save-slots::-webkit-scrollbar-track {
      background: #333;
    }

    .save-slots::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }

  </style>
</head>
<body>

  <header>
    <h1></h1>
    <div class="selector-row">
      <label for="colorSelect">Choose Color:</label>
      
      <!-- Custom Dropdown -->
      <div class="custom-dropdown" aria-haspopup="true" aria-expanded="false">
        <button class="dropdown-button" id="dropdownButton" aria-label="Select Color">
          <div class="swatch" id="currentSwatch" style="background-color: #FF0000;"></div>
          <span id="currentColorName">Red</span>
        </button>
        <div class="dropdown-content" id="dropdownContent" role="menu">
          <!-- Crayola Color Palette -->
          <div class="dropdown-item" data-color="#FF0000" data-name="Red" tabindex="0">
            <div class="swatch" style="background-color: #FF0000;"></div>
            Red
          </div>
          <div class="dropdown-item" data-color="#FF7F00" data-name="Orange" tabindex="0">
            <div class="swatch" style="background-color: #FF7F00;"></div>
            Orange
          </div>
          <div class="dropdown-item" data-color="#FFFF00" data-name="Yellow" tabindex="0">
            <div class="swatch" style="background-color: #FFFF00;"></div>
            Yellow
          </div>
          <div class="dropdown-item" data-color="#00FF00" data-name="Green" tabindex="0">
            <div class="swatch" style="background-color: #00FF00;"></div>
            Green
          </div>
          <div class="dropdown-item" data-color="#0000FF" data-name="Blue" tabindex="0">
            <div class="swatch" style="background-color: #0000FF;"></div>
            Blue
          </div>
          <div class="dropdown-item" data-color="#4B0082" data-name="Indigo" tabindex="0">
            <div class="swatch" style="background-color: #4B0082;"></div>
            Indigo
          </div>
          <div class="dropdown-item" data-color="#9400D3" data-name="Violet" tabindex="0">
            <div class="swatch" style="background-color: #9400D3;"></div>
            Violet
          </div>
          <div class="dropdown-item" data-color="#FFC0CB" data-name="Pink" tabindex="0">
            <div class="swatch" style="background-color: #FFC0CB;"></div>
            Pink
          </div>
          <div class="dropdown-item" data-color="#A52A2A" data-name="Brown" tabindex="0">
            <div class="swatch" style="background-color: #A52A2A;"></div>
            Brown
          </div>
          <div class="dropdown-item" data-color="#FFFFFF" data-name="White" tabindex="0">
            <div class="swatch" style="background-color: #FFFFFF;"></div>
            White
          </div>
          <div class="dropdown-item" data-color="#000000" data-name="Black" tabindex="0">
            <div class="swatch" style="background-color: #000000;"></div>
            Black
          </div>
          <div class="dropdown-item" data-color="#00CED1" data-name="Dark Turquoise" tabindex="0">
            <div class="swatch" style="background-color: #00CED1;"></div>
            Dark Turquoise
          </div>
          <div class="dropdown-item" data-color="#FFD700" data-name="Gold" tabindex="0">
            <div class="swatch" style="background-color: #FFD700;"></div>
            Gold
          </div>
          <div class="dropdown-item" data-color="#ADFF2F" data-name="Green Yellow" tabindex="0">
            <div class="swatch" style="background-color: #ADFF2F;"></div>
            Green Yellow
          </div>
          <div class="dropdown-item" data-color="#7FFFD4" data-name="Aquamarine" tabindex="0">
            <div class="swatch" style="background-color: #7FFFD4;"></div>
            Aquamarine
          </div>
          <div class="dropdown-item" data-color="#FF69B4" data-name="Hot Pink" tabindex="0">
            <div class="swatch" style="background-color: #FF69B4;"></div>
            Hot Pink
          </div>
          <div class="dropdown-item" data-color="#800080" data-name="Purple" tabindex="0">
            <div class="swatch" style="background-color: #800080;"></div>
            Purple
          </div>
          <div class="dropdown-item" data-color="#FFA500" data-name="Orange Red" tabindex="0">
            <div class="swatch" style="background-color: #FFA500;"></div>
            Orange Red
          </div>
          <div class="dropdown-item" data-color="#DC143C" data-name="Crimson" tabindex="0">
            <div class="swatch" style="background-color: #DC143C;"></div>
            Crimson
          </div>
          <div class="dropdown-item" data-color="#8A2BE2" data-name="Blue Violet" tabindex="0">
            <div class="swatch" style="background-color: #8A2BE2;"></div>
            Blue Violet
          </div>
          <!-- Add more colors as desired -->
        </div>
      </div>

      <button id="eraserButton" title="Activate Eraser">Eraser</button>
      <button id="clearBoard" title="Clear All Pegs">Clear Board</button>
      <button id="saveLoadButton" title="Save or Load Pegboards">Save/Load</button>
    </div>
  </header>

  <main>
    <div class="board-container">
      <svg id="lightBrightBoard" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
  </main>

  <!-- Save/Load Modal -->
  <div class="modal" id="saveLoadModal" aria-hidden="true" role="dialog" aria-labelledby="saveLoadModalTitle">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="saveLoadModalTitle">Save Manager</h2>
        <button class="close-modal" id="closeSaveLoadModal" aria-label="Close Save/Load Modal">&times;</button>
      </div>
      <div class="save-slots">
        <!-- Four Save Slots -->
        <div class="save-slot" data-slot="1">
          <div class="save-slot-info">
            <input type="text" id="slot-name-1" placeholder="Slot 1" aria-label="Slot 1 Name">
            <button class="save-name-button" title="Save Slot 1 Name" aria-label="Save Slot 1 Name">✔</button>
            <div class="save-slot-preview" id="slot-preview-1"></div>
          </div>
          <div class="save-slot-buttons">
            <button class="save-button" title="Save to Slot 1">Save</button>
            <button class="load-button" title="Load from Slot 1">Load</button>
            <button class="delete-button" title="Delete Slot 1">Delete</button>
          </div>
        </div>
        <div class="save-slot" data-slot="2">
          <div class="save-slot-info">
            <input type="text" id="slot-name-2" placeholder="Slot 2" aria-label="Slot 2 Name">
            <button class="save-name-button" title="Save Slot 2 Name" aria-label="Save Slot 2 Name">✔</button>
            <div class="save-slot-preview" id="slot-preview-2"></div>
          </div>
          <div class="save-slot-buttons">
            <button class="save-button" title="Save to Slot 2">Save</button>
            <button class="load-button" title="Load from Slot 2">Load</button>
            <button class="delete-button" title="Delete Slot 2">Delete</button>
          </div>
        </div>
        <div class="save-slot" data-slot="3">
          <div class="save-slot-info">
            <input type="text" id="slot-name-3" placeholder="Slot 3" aria-label="Slot 3 Name">
            <button class="save-name-button" title="Save Slot 3 Name" aria-label="Save Slot 3 Name">✔</button>
            <div class="save-slot-preview" id="slot-preview-3"></div>
          </div>
          <div class="save-slot-buttons">
            <button class="save-button" title="Save to Slot 3">Save</button>
            <button class="load-button" title="Load from Slot 3">Load</button>
            <button class="delete-button" title="Delete Slot 3">Delete</button>
          </div>
        </div>
        <div class="save-slot" data-slot="4">
          <div class="save-slot-info">
            <input type="text" id="slot-name-4" placeholder="Slot 4" aria-label="Slot 4 Name">
            <button class="save-name-button" title="Save Slot 4 Name" aria-label="Save Slot 4 Name">✔</button>
            <div class="save-slot-preview" id="slot-preview-4"></div>
          </div>
          <div class="save-slot-buttons">
            <button class="save-button" title="Save to Slot 4">Save</button>
            <button class="load-button" title="Load from Slot 4">Load</button>
            <button class="delete-button" title="Delete Slot 4">Delete</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Confirmation Modal -->
  <div class="confirmation-modal" id="confirmationModal" aria-hidden="true" role="dialog" aria-labelledby="confirmationModalTitle">
    <div class="confirmation-content">
      <h3 id="confirmationModalTitle">Unsaved Changes</h3>
      <p>You have unsaved changes. Would you like to save them before proceeding?</p>
      <div class="confirmation-buttons">
        <button class="confirm" id="confirmSave">Save</button>
        <button class="discard" id="confirmDiscard">Discard</button>
        <button class="cancel" id="cancelAction">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const customDropdown = document.querySelector('.custom-dropdown');
      const dropdownContent = document.getElementById('dropdownContent');
      const currentSwatch = document.getElementById('currentSwatch');
      const currentColorName = document.getElementById('currentColorName');
      const eraserButton = document.getElementById('eraserButton');
      const clearButton = document.getElementById('clearBoard');
      const svgBoard    = document.getElementById('lightBrightBoard');
      const board       = document.querySelector('.board-container');
      const header      = document.querySelector('header');

      // New Elements for Save/Load
      const saveLoadButton     = document.getElementById('saveLoadButton');
      const saveLoadModal      = document.getElementById('saveLoadModal');
      const closeSaveLoadModal = document.getElementById('closeSaveLoadModal');
      const saveSlots          = document.querySelectorAll('.save-slot');
      const confirmationModal  = document.getElementById('confirmationModal');
      const confirmSaveBtn     = document.getElementById('confirmSave');
      const confirmDiscardBtn  = document.getElementById('confirmDiscard');
      const cancelActionBtn    = document.getElementById('cancelAction');

      // Configuration
      const pegSpacing = 25; // Pixels between centers of pegs
      const pegRadius = pegSpacing / 2.2; // Radius of each peg

      let cols, rows, rowOffset, containerWidth, containerHeight;
      let currentColor = null; // Current drawing color
      let isEraser = false; // Eraser mode flag

      // Load saved drawing from localStorage
      let savedDrawing = JSON.parse(localStorage.getItem('lightBrightDrawing')) || {};

      // Track if current board has unsaved changes
      let isBoardModified = false;

      // Function to calculate and create pegs
      function createPegs() {
        // Clear existing pegs
        while (svgBoard.firstChild) {
          svgBoard.removeChild(svgBoard.firstChild);
        }

        // Measure the board container to figure out how many pegs can fit
        const rect = board.getBoundingClientRect();
        containerWidth  = rect.width;
        containerHeight = rect.height;

        // Calculate how many columns & rows we can fit
        cols = Math.floor(containerWidth  / pegSpacing);
        rows = Math.floor(containerHeight / pegSpacing);

        // Offset for staggered rows
        rowOffset = pegSpacing / 2;

        // Set the SVG coordinate system to match the container size
        svgBoard.setAttribute('viewBox', `0 0 ${containerWidth} ${containerHeight}`);

        // Generate the peg circles
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            // Calculate x,y in the SVG coordinate system
            const x = (r % 2 === 0) 
              ? c * pegSpacing
              : c * pegSpacing + rowOffset; // offset every other row
            const y = r * pegSpacing;

            // Create an SVG group to hold the peg and its highlight
            const pegGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            // Create the main peg circle
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', x + pegSpacing/2);
            circle.setAttribute('cy', y + pegSpacing/2);
            // The radius is slightly smaller than half the spacing
            circle.setAttribute('r', pegRadius);
            circle.setAttribute('fill', '#111'); // Default color changed to #111
            circle.style.cursor = 'pointer';
            circle.setAttribute('data-index', r * cols + c); // Unique index for each peg
            circle.classList.add('peg');

            // Apply saved color if exists and not default
            if (savedDrawing[r * cols + c] && savedDrawing[r * cols + c] !== '#111') {
              circle.setAttribute('fill', savedDrawing[r * cols + c]);
              // Apply glow effect
              circle.style.filter = `drop-shadow(0 0 5px ${savedDrawing[r * cols + c]})`;
            }

            // Create the highlight circle
            const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            highlight.setAttribute('cx', (x + pegSpacing/2) - pegRadius * 0.3);
            highlight.setAttribute('cy', (y + pegSpacing/2) - pegRadius * 0.3);
            highlight.setAttribute('r', pegRadius * 0.4);
            highlight.setAttribute('fill', 'white');
            highlight.setAttribute('opacity', (savedDrawing[r * cols + c] && savedDrawing[r * cols + c] !== '#111') ? '0.3' : '0');
            highlight.style.pointerEvents = 'none'; // Allow pointer events to pass through
            highlight.classList.add('highlight');

            // Append circles to the group
            pegGroup.appendChild(circle);
            pegGroup.appendChild(highlight);

            // Append the group to the SVG board
            svgBoard.appendChild(pegGroup);
          }
        }
      }

      // Initial peg creation
      createPegs();

      // Recalculate pegs on window resize for responsiveness with debouncing
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          createPegs();
        }, 200);
      });

      // Track whether we are currently "painting" (dragging with pointer down)
      let isDrawing = false;
      let coloredPegs = new Set(); // To prevent recoloring the same peg multiple times during a drag

      // Helper function to get the peg under the pointer
      function getPegUnderPointer(event) {
        const point = svgBoard.createSVGPoint();
        point.x = event.clientX;
        point.y = event.clientY;

        // Transform the point to SVG coordinates
        const ctm = svgBoard.getScreenCTM().inverse();
        const svgPoint = point.matrixTransform(ctm);

        // Calculate the closest peg indices
        const col = Math.floor(svgPoint.x / pegSpacing);
        const row = Math.floor(svgPoint.y / pegSpacing);

        // Calculate potential neighboring pegs due to offset
        const possiblePegs = [];

        // Current row and adjacent rows may have overlapping pegs due to offset
        possiblePegs.push({ r: row, c: col });
        if (row > 0) possiblePegs.push({ r: row - 1, c: col });
        if (row < rows -1) possiblePegs.push({ r: row + 1, c: col });

        // Iterate through possible pegs to find the one under the pointer
        for (const peg of possiblePegs) {
          const r = peg.r;
          const c = peg.c;

          if (r >= 0 && r < rows && c >= 0 && c < cols) {
            const index = r * cols + c;
            const pegGroup = svgBoard.children[index];
            if (!pegGroup) continue;

            const circle = pegGroup.querySelector('circle.peg');

            // Calculate distance from pointer to peg center
            const cx = parseFloat(circle.getAttribute('cx'));
            const cy = parseFloat(circle.getAttribute('cy'));
            const distance = Math.hypot(svgPoint.x - cx, svgPoint.y - cy);

            if (distance <= pegRadius) {
              return circle;
            }
          }
        }

        return null;
      }

      // Function to color or erase a peg
      function colorPeg(circle) {
        if (circle && !coloredPegs.has(circle)) {
          let selectedColor = currentColor;
          if (isEraser) {
            selectedColor = '#111'; // Eraser sets peg to #111
          }

          circle.setAttribute('fill', selectedColor);
          coloredPegs.add(circle);
          isBoardModified = true; // Mark board as modified

          // Apply or remove glow effect
          if (selectedColor !== '#111') {
            circle.style.filter = `drop-shadow(0 0 5px ${selectedColor})`;
          } else {
            circle.style.filter = '';
          }

          // Access the highlight circle
          const highlight = circle.parentElement.querySelector('circle.highlight');
          if (selectedColor !== '#111') {
            highlight.setAttribute('opacity', '0.3');
          } else {
            highlight.setAttribute('opacity', '0');
          }

          // Save the color to localStorage
          const index = circle.getAttribute('data-index');
          savedDrawing[index] = selectedColor;
          localStorage.setItem('lightBrightDrawing', JSON.stringify(savedDrawing));

          // Update thumbnail previews if necessary
          updateAllThumbnails();
        }
      }

      // Pointer event handlers
      svgBoard.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default touch behaviors
        isDrawing = true;
        coloredPegs.clear();

        const peg = getPegUnderPointer(e);
        colorPeg(peg);
      });

      svgBoard.addEventListener('pointermove', (e) => {
        if (!isDrawing) return;
        e.preventDefault(); // Prevent default touch behaviors

        const peg = getPegUnderPointer(e);
        colorPeg(peg);
      });

      // Stop drawing when pointer is lifted or leaves the SVG area
      svgBoard.addEventListener('pointerup', () => {
        isDrawing = false;
        coloredPegs.clear();
      });

      svgBoard.addEventListener('pointerleave', () => {
        isDrawing = false;
        coloredPegs.clear();
      });

      // Also stop drawing when pointer is lifted anywhere on the document
      document.addEventListener('pointerup', () => {
        isDrawing = false;
        coloredPegs.clear();
      });

      // Clear Board Functionality
      clearButton.addEventListener('click', () => {
        const allPegGroups = svgBoard.querySelectorAll('g');
        allPegGroups.forEach(pegGroup => {
          const circle = pegGroup.querySelector('circle.peg');
          const highlight = pegGroup.querySelector('circle.highlight');
          circle.setAttribute('fill', '#111'); // Reset to #111
          circle.style.filter = ''; // Remove glow effect
          highlight.setAttribute('opacity', '0'); // Hide highlight
          const index = circle.getAttribute('data-index');
          savedDrawing[index] = '#111';
        });
        localStorage.setItem('lightBrightDrawing', JSON.stringify(savedDrawing));
        isBoardModified = false; // Reset modification flag

        // **Option B:** Keep the current selected color
        header.classList.remove('eraser-mode');
        triggerHeaderSweepAnimation();

        // Update all thumbnails to show cleared state
        updateAllThumbnails();
      });

      // Eraser Button Functionality
      eraserButton.addEventListener('click', () => {
        isEraser = !isEraser; // Toggle eraser mode
        if (isEraser) {
          eraserButton.classList.add('active');
          eraserButton.textContent = 'Eraser (On)';
          toggleHeaderBackgroundForEraser(true);
        } else {
          eraserButton.classList.remove('active');
          eraserButton.textContent = 'Eraser';
          toggleHeaderBackgroundForEraser(false);
        }
      });


      // Function to handle color selection
      function selectColor(color, name) {
        currentColor = color;
        isEraser = false;
        eraserButton.classList.remove('active');
        eraserButton.textContent = 'Eraser';
        currentSwatch.style.backgroundColor = color;
        currentColorName.textContent = name;
        dropdownContent.classList.remove('show');

        // Update the header background color
        updateHeaderBackground(color);
      }

      // Function to update the header's gradient background
      function updateHeaderBackground(color) {
        // Update the CSS variable
        document.documentElement.style.setProperty('--selected-color', color);

        // Trigger the sweep animation
        triggerHeaderSweepAnimation();
      }

      // Function to toggle header background for eraser mode
      function toggleHeaderBackgroundForEraser(isEraserActive) {
        if (isEraserActive) {
          header.classList.add('eraser-mode');
        } else {
          header.classList.remove('eraser-mode');
          // Optionally reset to the current selected color
          document.documentElement.style.setProperty('--selected-color', currentColor);
          triggerHeaderSweepAnimation();
        }
      }

      // Function to trigger the sweep animation
      function triggerHeaderSweepAnimation() {
        // Remove the animation class if it's already present to allow re-triggering
        header.classList.remove('animate-sweep');

        // Trigger reflow to restart the animation
        void header.offsetWidth;

        // Add the animation class
        header.classList.add('animate-sweep');
      }

      // Handle dropdown toggle on the entire custom-dropdown
      customDropdown.addEventListener('click', (event) => {
        // Prevent the event from bubbling up to the window click listener
        event.stopPropagation();
        const isExpanded = dropdownContent.classList.toggle('show');
        customDropdown.setAttribute('aria-expanded', isExpanded);

        if (isExpanded) {
          // Focus the first dropdown item when opened
          const firstItem = dropdownContent.querySelector('.dropdown-item');
          if (firstItem) {
            firstItem.focus();
          }
        }
      });

      // Handle color selection from dropdown
      const dropdownItems = document.querySelectorAll('.dropdown-item');
      dropdownItems.forEach((item, index) => {
        item.addEventListener('click', (event) => {
          event.stopPropagation(); // Prevent the dropdown from closing immediately
          const color = item.getAttribute('data-color');
          const name = item.getAttribute('data-name');
          selectColor(color, name);

          // Update active state
          dropdownItems.forEach(i => i.classList.remove('active'));
          item.classList.add('active');
        });

        // Keyboard navigation for dropdown items
        item.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            item.click();
          }
        });
      });

      // Close the dropdown if clicked outside
      window.addEventListener('click', (event) => {
        if (!customDropdown.contains(event.target)) {
          if (dropdownContent.classList.contains('show')) {
            dropdownContent.classList.remove('show');
            customDropdown.setAttribute('aria-expanded', 'false');
          }
        }
      });

      // Initialize the dropdown to the first color
      function initializeDefaultColor() {
        const firstItem = document.querySelector('.dropdown-item');
        if (firstItem) {
          const color = firstItem.getAttribute('data-color');
          const name = firstItem.getAttribute('data-name');
          selectColor(color, name);
          firstItem.classList.add('active'); // Set the first item as active
        }
      }

      initializeDefaultColor();

      /* ------------------ Save/Load Functionality ------------------ */

      // Open Save/Load Modal
      saveLoadButton.addEventListener('click', () => {
        updateSaveSlotsUI();
        saveLoadModal.style.display = 'flex';
        saveLoadModal.setAttribute('aria-hidden', 'false');
      });

      // Close Save/Load Modal
      closeSaveLoadModal.addEventListener('click', () => {
        saveLoadModal.style.display = 'none';
        saveLoadModal.setAttribute('aria-hidden', 'true');
      });

      // Function to update the UI of save slots
      function updateSaveSlotsUI() {
        saveSlots.forEach(slot => {
          const slotNumber = slot.getAttribute('data-slot');
          const slotNameInput = document.getElementById(`slot-name-${slotNumber}`);
          const slotPreview = document.getElementById(`slot-preview-${slotNumber}`);
          const savedName = localStorage.getItem(`lightBrightSlot${slotNumber}Name`);
          if (savedName && savedName !== 'Empty') {
            slotNameInput.value = savedName;
            slotNameInput.placeholder = savedName;
          } else {
            slotNameInput.value = '';
            slotNameInput.placeholder = `Slot ${slotNumber}`;
          }

          // Generate thumbnail preview
          generateThumbnail(slotNumber);
        });
      }

      // Handle Save, Load, and Delete Buttons
      saveSlots.forEach(slot => {
        const slotNumber = slot.getAttribute('data-slot');
        const saveButton = slot.querySelector('.save-button');
        const loadButton = slot.querySelector('.load-button');
        const deleteButton = slot.querySelector('.delete-button');
        const slotNameInput = document.getElementById(`slot-name-${slotNumber}`);
        const saveNameButton = slot.querySelector('.save-name-button');

        // Save Button (Saves the pegboard to the slot)
        saveButton.addEventListener('click', () => {
          const existingData = localStorage.getItem(`lightBrightSlot${slotNumber}`);
          const slotName = slotNameInput.value.trim() || `Slot ${slotNumber}`;

          if (existingData) {
            // Prompt to overwrite
            const confirmOverwrite = confirm(`Slot ${slotNumber} already has a saved pegboard. Do you want to overwrite it?`);
            if (!confirmOverwrite) {
              return;
            }
          }

          // Save the current board to this slot
          saveCurrentBoard(slotNumber, slotName);
        });

        // Load Button
        loadButton.addEventListener('click', () => {
          const slotData = localStorage.getItem(`lightBrightSlot${slotNumber}`);
          if (!slotData) {
            alert('This slot is empty.');
            return;
          }

          if (isBoardModified) {
            // Prompt the user to save or discard changes before loading
            confirmationModal.style.display = 'flex';
            confirmationModal.setAttribute('aria-hidden', 'false');

            // Store the target slot to load after confirmation
            confirmationModal.dataset.targetSlot = slotNumber;
            confirmationModal.dataset.action = 'load';
          } else {
            // Directly load the slot
            loadSlot(slotNumber);
          }
        });

        // Delete Button
        deleteButton.addEventListener('click', () => {
          const confirmDelete = confirm(`Are you sure you want to delete Slot ${slotNumber}?`);
          if (confirmDelete) {
            localStorage.removeItem(`lightBrightSlot${slotNumber}`);
            localStorage.removeItem(`lightBrightSlot${slotNumber}Name`);
            updateSaveSlotsUI();
          }
        });

        // Save Name Button (Checkmark)
        saveNameButton.addEventListener('click', () => {
          const newName = slotNameInput.value.trim();
          if (newName === '') {
            alert('Slot name cannot be empty.');
            slotNameInput.focus();
            return;
          }

          // Save the name to localStorage
          localStorage.setItem(`lightBrightSlot${slotNumber}Name`, newName);
          alert(`Slot ${slotNumber} name has been updated to "${newName}".`);

          // Update the placeholder to reflect the saved name
          slotNameInput.placeholder = newName;
        });

        // Handle Enter key for saving the name
        slotNameInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveNameButton.click();
          }
        });
      });

      // Save/Load Modal Close on outside click
      window.addEventListener('click', (event) => {
        if (event.target === saveLoadModal) {
          saveLoadModal.style.display = 'none';
          saveLoadModal.setAttribute('aria-hidden', 'true');
        }
        if (event.target === confirmationModal) {
          confirmationModal.style.display = 'none';
          confirmationModal.setAttribute('aria-hidden', 'true');
          delete confirmationModal.dataset.targetSlot;
          delete confirmationModal.dataset.action;
        }
      });

      // Confirmation Modal Buttons
      confirmSaveBtn.addEventListener('click', () => {
        const targetSlot = confirmationModal.dataset.targetSlot;
        const action = confirmationModal.dataset.action;
        if (action === 'load') {
          const slotNameInput = document.getElementById(`slot-name-${targetSlot}`);
          const slotName = slotNameInput.value.trim() || `Slot ${targetSlot}`;
          saveCurrentBoard(targetSlot, slotName, () => {
            confirmationModal.style.display = 'none';
            confirmationModal.setAttribute('aria-hidden', 'true');
            loadSlot(targetSlot);
          });
        } else {
          // Future actions can be handled here
          confirmationModal.style.display = 'none';
          confirmationModal.setAttribute('aria-hidden', 'true');
          delete confirmationModal.dataset.targetSlot;
          delete confirmationModal.dataset.action;
        }
      });

      confirmDiscardBtn.addEventListener('click', () => {
        const targetSlot = confirmationModal.dataset.targetSlot;
        const action = confirmationModal.dataset.action;
        if (action === 'load') {
          confirmationModal.style.display = 'none';
          confirmationModal.setAttribute('aria-hidden', 'true');
          loadSlot(targetSlot);
        } else {
          // Future actions can be handled here
          confirmationModal.style.display = 'none';
          confirmationModal.setAttribute('aria-hidden', 'true');
          delete confirmationModal.dataset.targetSlot;
          delete confirmationModal.dataset.action;
        }
      });

      cancelActionBtn.addEventListener('click', () => {
        confirmationModal.style.display = 'none';
        confirmationModal.setAttribute('aria-hidden', 'true');
        delete confirmationModal.dataset.targetSlot;
        delete confirmationModal.dataset.action;
      });

      // Function to save current board to a slot
      function saveCurrentBoard(slotNumber, slotName, callback) {
        // Save the drawing
        localStorage.setItem(`lightBrightSlot${slotNumber}`, JSON.stringify(savedDrawing));
        localStorage.setItem(`lightBrightSlot${slotNumber}Name`, slotName);
        updateSaveSlotsUI();
        isBoardModified = false; // Reset modification flag
        if (callback) callback();
      }

      // Function to load a board from a slot
      function loadSlot(slotNumber) {
        const slotData = JSON.parse(localStorage.getItem(`lightBrightSlot${slotNumber}`));
        if (!slotData) {
          alert('This slot is empty.');
          return;
        }

        // Clear current board
        const allPegGroups = svgBoard.querySelectorAll('g');
        allPegGroups.forEach(pegGroup => {
          const circle = pegGroup.querySelector('circle.peg');
          const highlight = pegGroup.querySelector('circle.highlight');
          circle.setAttribute('fill', '#111'); // Reset to #111
          circle.style.filter = ''; // Remove glow effect
          highlight.setAttribute('opacity', '0'); // Hide highlight
        });

        // Apply the loaded drawing
        for (const [index, color] of Object.entries(slotData)) {
          const pegGroup = svgBoard.children[index];
          if (pegGroup) {
            const circle = pegGroup.querySelector('circle.peg');
            const highlight = pegGroup.querySelector('circle.highlight');
            circle.setAttribute('fill', color);
            if (color !== '#111') {
              circle.style.filter = `drop-shadow(0 0 5px ${color})`;
              highlight.setAttribute('opacity', '0.3');
            } else {
              circle.style.filter = '';
              highlight.setAttribute('opacity', '0');
            }
          }
        }

        // Update the current saved drawing
        savedDrawing = slotData;
        localStorage.setItem('lightBrightDrawing', JSON.stringify(savedDrawing));
        isBoardModified = false; // Reset modification flag

        // Close the Save/Load modal
        saveLoadModal.style.display = 'none';
        saveLoadModal.setAttribute('aria-hidden', 'true');
      }

      // Function to check if current board differs from savedDrawing
      function checkUnsavedChanges() {
        const currentDrawing = JSON.parse(localStorage.getItem('lightBrightDrawing')) || {};
        // Compare currentDrawing with savedDrawing
        for (const key in currentDrawing) {
          if (currentDrawing[key] !== savedDrawing[key]) {
            return true;
          }
        }
        return false;
      }

      // Listen to changes to mark the board as modified
      const observer = new MutationObserver(() => {
        if (checkUnsavedChanges()) {
          isBoardModified = true;
        } else {
          isBoardModified = false;
        }
      });

      observer.observe(svgBoard, { attributes: true, childList: true, subtree: true });

      /* ------------------ Thumbnail Preview Functionality ------------------ */

      // Function to generate a thumbnail preview for a given slot
      function generateThumbnail(slotNumber) {
        const slotData = JSON.parse(localStorage.getItem(`lightBrightSlot${slotNumber}`));
        const previewDiv = document.getElementById(`slot-preview-${slotNumber}`);
        
        // Clear previous thumbnail
        while (previewDiv.firstChild) {
          previewDiv.removeChild(previewDiv.firstChild);
        }
        
        if (!slotData) {
          // No saved data, leave it empty or show a placeholder
          return;
        }

        // Define thumbnail SVG dimensions
        const thumbWidth = 60;
        const thumbHeight = 60;
        const thumbCols = 10;
        const thumbRows = 10;
        const thumbPegSpacingX = thumbWidth / thumbCols;
        const thumbPegSpacingY = thumbHeight / thumbRows;
        const thumbPegRadius = Math.min(thumbPegSpacingX, thumbPegSpacingY) / 2.2;

        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", thumbWidth);
        svg.setAttribute("height", thumbHeight);

        // Iterate through the thumbnail grid
        for (let r = 0; r < thumbRows; r++) {
          for (let c = 0; c < thumbCols; c++) {
            const index = r * thumbCols + c;
            const color = slotData[index] || '#111'; // default color
            
            // Create circle
            const circle = document.createElementNS(svgNS, "circle");
            circle.setAttribute('cx', c * thumbPegSpacingX + thumbPegSpacingX / 2);
            circle.setAttribute('cy', r * thumbPegSpacingY + thumbPegSpacingY / 2);
            circle.setAttribute('r', thumbPegRadius);
            circle.setAttribute('fill', color);
            svg.appendChild(circle);
          }
        }

        previewDiv.appendChild(svg);
      }

      // Function to update all thumbnails (called when board is modified)
      function updateAllThumbnails() {
        saveSlots.forEach(slot => {
          const slotNumber = slot.getAttribute('data-slot');
          generateThumbnail(slotNumber);
        });
      }

      /* ------------------ End of Thumbnail Preview Functionality ------------------ */

    });
  </script>
</body>
</html>
